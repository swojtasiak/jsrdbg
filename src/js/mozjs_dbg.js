/*
 * A Remote Debugger for SpiderMonkey Java Script engine.
 * Copyright (C) 2014-2015 SÅ‚awomir Wojtasiak
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */

(function() {

    var dbgModule = require('dbg/module');
    
    // Change it to true in order to enable experimental functionalities
    // that should be available in the release build yet.

    const EXPERIMENTAL = false;

    // Register logger.
    
    env.log = function( msg ) {
        if( env.isLoggerEnabled() ) {
            env.print( msg );
        }
    };
    
    env.isLoggerEnabled = function() {
        return env.debug;
    };
    
    // Set default displacement if there isn't any.
    
    if( env.options.sourceDisplacement === undefined ) {
        env.options.sourceDisplacement = 0;
    }
    
    // Error codes.
    
    const ERROR_CODE_UNKNOWN_COMMAND       = 1;
    const ERROR_CODE_NO_COMMAND_NAME       = 2;
    const ERROR_CODE_NOT_A_COMMAND_PACKAGE = 3;
    const ERROR_CODE_NOT_PAUSED            = 4;
    const ERROR_CODE_BAD_ARGS              = 5;
    const ERROR_CODE_SCRIPT_NOT_FOUND      = 6;
    const ERROR_CODE_CANNOT_SET_BREAKPOINT = 8;
    const ERROR_CODE_IS_PAUSED             = 9;
    const ERROR_CODE_UNEXPECTED_EXC        = 10;
    const ERROR_CODE_EVALUATION_FAILED     = 11;
    const ERROR_CODE_PC_NOT_AVAILABLE      = 12;
    const ERROR_CODE_NO_ACTIVE_FRAME       = 13;

    // Following constans describes values that can be returned
    // be handleCommand function to the core engine. They are used
    // to control debugger execution mode.

    // Make a debugger to break the command loop and continue execution.
    const HC_RES_CONTINUE     = 1;
    // Do not change the debugger state. If it is paused it
    // will remain in this state.
    const HC_RES_IGNORE       = 2;
    // Inform the core engine that debugger has been interrupted. It's
    // just pass through message, because it's mainly generated by the
    // engine itself in a form of exception.
    const HC_RES_INTERRUPTED  = 3;
    
    const PKG_TYPE_INFO    = "info";
    const PKG_TYPE_ERROR   = "error";
    
    const HANDLER_TYPE_FRAME = "frame";
    const HANDLER_TYPE_DBG   = "dbg";
    
    const WFC_RES_INTERRUPTED = 1;
    const WFC_RES_CONTINUE    = 0;
    
    const BROADCAST = -1;

    /**
     * Gets frame's location in the source script.
     */
    function Location( obj ) {
        if( obj instanceof Debugger.Frame ) {
            // Points to a line in a global source script not to a part covering given frame.
            this._line = obj.script.getOffsetLine( obj.offset );
            obj = obj.script;
        }
        if( obj instanceof Debugger.Script ) {
            this._url = obj.url;
            this._script = obj;
        }
    }

    Location.prototype = {
        getURL: function() {
            return this._url;
        },
        getScriptLine: function() {
            return this._line;
        },
        getScript: function() {
            return this._script;
        }
    };

    // ***************
    // Utils
    // ***************

    function Utils() {
    }

    /**
     * Gets source code line for given location.
     */
    Utils.getSourceLine = function( source ) {
        if( source instanceof ProgramCounter ) {
            source = source.getLocation();
        }
        if( !(source instanceof Location) ) {
            throw "PC or Location expected!";
        }
        var script = scriptsRepository.getScriptSourceCode( source.getURL(), source.getScriptLine(), source.getScript() );
        var sourceCode = null;
        if( script ) {
            sourceCode = script.getSourceLine( source.getScriptLine() );
        }
        return sourceCode;
    };
    
    /**
     * Inheritance implementation.
     */
    Utils.Inherit = function( NewType, SubType, ext ) {
        function F() {}
        F.prototype = SubType.prototype;
        NewType.prototype = new F();
        if( ext ) {
            Utils.Extends( NewType, ext );
        }
    };
    
    /**
     * Extends given type by adding provided 
     * set of functions into its prototype.
     */
    Utils.Extends = function( Type, functions ) {
        for( let f in functions ) {
            Type.prototype[f] = functions[f];
        }
    };
    
    /**
     * Logs some information about location in the frame.
     */
    Utils.logLocation = function( frame, where ) {
        env.print( 'Location: ' + ( where ? where : '' ) );
        env.print( ' > offset: ' + frame.offset );
        let line = frame.script.getOffsetLine( frame.offset );
        env.print( ' > offset-line: ' + line );
        env.print( ' > line-offsets: ' + frame.script.getLineOffsets( line ) );
        env.print( ' > displacement: ' + env.options.sourceDisplacement );
        var loc = new Location( frame );
        env.print( ' > line: ' + loc.getScriptLine() );
        env.print( ' > live: ' + frame.live );
        env.print( ' > script: ' + loc.getURL() );
        if( frame.script ) {
            let script = frame.script;
            env.print( 'Script: ' );
            env.print( ' > staticLevel: ' + script.staticLevel );
            env.print( ' > startLine: ' + script.startLine );
            env.print( ' > lineCount: ' + script.lineCount );
            env.print( ' > sourceStart: ' + script.sourceStart );
            env.print( ' > sourceLength: ' + script.sourceLength );
        }
    };
    
    /**
     * Gets dwfault value if undefined.
     */
    Utils.getDef = function( obj, property, def ) {
        return (obj[property] !== undefined) ? obj[property] : def;
    };
    
    /**
     * Logs exception if debugging is enabled.
     */
    Utils.logException = function( ex ) {
        if( env.isLoggerEnabled() ) {
            env.print( "Exception: " + ex + "\nType: " + typeof(ex) + "\nStack: " + ex.stack );
            env.print( "Exception has been logged here: " + new Error().stack );
        }
    };
    
    /**
     * Handles exceptions thrown in JS Debugger callbacks like
     * breakpoints or on step handlers.
     */
    Utils.handleCallbackException = function( ex ) {
        env.log( 'Unhandled exceptions handler.' );
        if( ex instanceof DebuggerInterrupted ) {
           // Debugger has been interrupted, so clean
           // everything up just now, in order to
           // avoid future calls to debugger's callbacks/handlers
           // during the shutdown procedure.
           dbg.shutdown();
        }
        Utils.logException( ex );
    };

    /*********************************************
     * Visites debugger object element by element.
     *********************************************/
     
    function ObjectWalker( visitor ) {
        this._visitor = visitor;
    }
    
    ObjectWalker.prototype = {
        walk: function( walker, obj ) {
        }
    };
    
    function DebuggerObjectWalker( visitor ) {
        ObjectWalker.call( this, visitor );
    }
    
    Utils.Inherit( DebuggerObjectWalker, ObjectWalker, {
        walkObj: function( obj, options ) {
            if( !options ) {
                options = {};
            }
            var maxDepth = Utils.getDef( options, 'evaluation-depth', 1 );
            var ctx =  { 
                depth: 0,
                options: options,
                isMaxDepth: function() {
                    return this.depth > maxDepth;
                }
            };
            ctx.walk = this.walk.bind( this, ctx );
            return this.walk( ctx, null, obj );
        },
        walk: function( ctx, property, obj ) {
            ctx.depth++;
            try {
                // Visit objects, but exclude all callables.
                if( obj instanceof Debugger.Object ) {
                    if( !ctx.isMaxDepth() ) {
                        var fn = this._visitor.newObject( ctx, property, obj );
                        // Walk over all object properties.
                        var names = obj.getOwnPropertyNames();
                        for( let ownName in names ) {
                            let name = names[ownName];
                            let value;
                            let desc = obj.getOwnPropertyDescriptor(name);
                            if( desc ) {
                                value = desc.value;
                            }
                            fn.call( this._visitor, ctx, name, value, obj['class'] );
                        }
                        if( obj.proto && ctx.options['show-hierarchy'] ) {
                            ctx.walk( '___jsrdbg___prototype___', obj.proto );
                        }                            
                        return this._visitor.pop();
                    } else {
                        // Max depth reached, so return collapsed object.
                        return this._visitor.collapsedObject();
                    }
                } else {
                    // Visit simple types.
                    return this._visitor.visit( ctx, property, obj );
                }
            } finally {
                ctx.depth--;
            }
        }
    } );

    function ObjectTreeVisitor() {
    }
    
    ObjectTreeVisitor.prototype = {
        
        newObject: function( ctx, objectProperty, obj ) {
            return function( ctx, property, value ) {
            };
        },
        
        collapsedObject: function() {
            return {
                ___jsrdbg_collapsed___: true
            };
        },
        
        pop: function() {
            return null;
        },
        
        visit: function( ctx, property, value ) {
        }
        
    };

    function DbgObjectTreeBuilder() {
        this.stack.push(this.result);
    }
    
    Utils.Inherit( DbgObjectTreeBuilder, ObjectTreeVisitor, {
    
        result: {
        },
        
        stack: [],
    
        newObject: function( ctx, objectProperty, obj ) {
            var holder = {};
            if( obj.callable ) {
                holder.___jsrdbg_function_desc___ = this._functionDescription( ctx, obj );
            }
            this._toStack( objectProperty, holder );
            return function( ctx, property, value, clazz ) {
                holder[property] = ctx.walk( property, value);
            };
        },
        
        pop: function() {
            return this.stack.pop();
        },
        
        visit: function( ctx, property, value ) {
            
            if( typeof(value) === 'undefined' ) {
                return '___jsrdbg_undefined___';
            }
            
            return value;
        },
        
        _functionDescription: function( ctx, fn ) {
            var desc = {};
            desc.displayName = fn.displayName;
            desc.name = fn.name;
            desc.parameterNames = fn.parameterNames;
            if( EXPERIMENTAL && fn.isBoundFunction ) {
                if( fn.boundTargetFunction ) {
                    desc.boundTargetFunction = ctx.walk(null, fn.boundTargetFunction);
                }
                if( fn.boundThis ) {
                    desc.boundThis = ctx.walk(null, fn.boundThis);
                }
                if( fn.boundArguments ) {
                    desc.boundArguments = [];
                    for( let boundArgKey in fn.boundArguments ) {
                        desc.boundArguments.push( ctx.walk(null, fn.boundArguments[boundArgKey] ) );
                    }
                }
            }
            return desc;
        },
        
        _toStack: function(property, obj) {
            if( property ) {
                this.stack[this.stack.length - 1][property] = obj;
            }
            this.stack.push(obj);
            return obj;
        }
        
    } );

    // ***************
    // Exceptions
    // ***************

    function DbgException( msg, code ) {
        this.msg = msg;
        this.code = code;
    }
    
    Utils.Inherit( DbgException, Error );
    
    function MediatorException( msg ) {
        this.msg = msg;
    }
    
    Utils.Inherit( MediatorException, Error );
    
    function DebuggerInterrupted() {
    }
    
    Utils.Inherit( DebuggerInterrupted, Error );

    // ***************
    // State handling.
    // ***************
    
    function ProgramCounter( frame ) {
        this._location = new Location( frame );
        this._frame = frame;
    }
    
    ProgramCounter.prototype = {
        getLocation: function() {
            return this._location;
        },
        getFrame: function() {
            return this._frame;
        },
        toString: function() {
            return '{Location:' + this._location.getURL() + ', Line:' + this._location.getScriptLine() + '}';
        }
    };
    
    function StateHandler() {
    }
    
    StateHandler.prototype = {
        
        /**
         * Registers state handler. By default a mediator function
         * 'registerDebuggerHandlers' is used to achieve it. Of course
         * concrete state handler can override it.
         */
        register: function( mediator ) {
            mediator.registerStateHandler( this );
        },
       
        /**
         * Provides a local state for the handlers.
         */
        _prepareHandler: function( mediator, type, frame, globalState, handler ) {
            var stateHandler = this;
            return {
                type: type,
                handler: function() {
                    var funcArgs = Array.prototype.slice.call(arguments);
                    var constArgs = [ mediator, frame, globalState ];
                    handler.apply( stateHandler, constArgs.concat( funcArgs ) );
                }
            };
        },
        
        /**
         * Prepares a positioned state for given frame.
         */
        _prepareState: function( frame, state ) {
            if( state === undefined ) {
                state = {};
            }
            state.frame = frame;
            state.location = new Location( frame );
            return state;
        },
        
        // ** Default handlers **
        
        /**
         * onStep frame handler.
         */
        _onStep_Handler: function( mediator, frame, state ) {

            if( env.isLoggerEnabled() ) {
                Utils.logLocation( frame, 'onStep' );
            }

            // Check if there is any source code associated with this instruction.
            // Ignore it if there is not, because we do not support anything like
            // byte code disassemblers.
            if( !frame.script || !frame.script.url ) {
                // Just continue, there is nothing to stop in.
                return;
            }
            
            // Gets current location and the one used by the previous handler.
            var prevLoc = state.location;
            var currLoc = new Location( frame );
            
            var pause = !prevLoc || // We are here (frame) for first time.
                    ( prevLoc.getURL() !== currLoc.getURL() || // Script file changed.
                    prevLoc.getScriptLine() !== currLoc.getScriptLine() ); // Source code line in the same script file changed.
            
            if( env.isLoggerEnabled() ) {
                env.print( 'pause: ' + pause + "" + ( prevLoc ? 
                    ( " url:" + prevLoc.getURL() + "-" + 
                    currLoc.getURL() + " line: " + prevLoc.getScriptLine() + 
                    "-" + currLoc.getScriptLine() ) : "" ) );
            }
            
            state.location = currLoc;
                
            if( pause ) {
                // Remember that we are in the context of mediator.
                try {
                    mediator.pause( frame );
                } catch( ex ) {
                    Utils.handleCallbackException( ex );
                }
            }

        },
        
        /**
         * onPop frame handler.
         */
        _onPop_Handler: function( mediator, frame, state ) {
        
            if( env.isLoggerEnabled() ) {
                Utils.logLocation( frame, 'onPop' );
            }
        
            try {
                mediator.pause( frame, frame.older );
            } catch( ex ) {
                Utils.handleCallbackException( ex );
                return;
            }
            
        }
    };
    
    // *********************
    // NEXT - State handler.
    // *********************
    
    function NextStateHandler() {
    }
    
    Utils.Inherit( NextStateHandler, StateHandler, {

        // List of handlers registered by this state handler.
        createStateHandlers: function( frame, mediator, state ) {
            state = this._prepareState( frame, state );
            return {
                state:  state,
                onStep: this._prepareHandler( mediator, HANDLER_TYPE_FRAME, frame, state, this._onStep_Handler ),
                onPop:  this._prepareHandler( mediator, HANDLER_TYPE_FRAME, frame, state, this._onPop_Handler )
            };
        }
        
    });
    
    // *********************
    // STEP - State handler.
    // *********************
    
    function StepStateHandler() {
    }
    
    Utils.Inherit( StepStateHandler, StateHandler, {

        // List of handlers registered by this state handler.
        createStateHandlers: function( frame, mediator, state ) {
            state = this._prepareState( frame, state );
            return {
                state:        state,
                onStep:       this._prepareHandler( mediator, HANDLER_TYPE_FRAME, frame, state, this._onStep_Handler ),
                onPop:        this._prepareHandler( mediator, HANDLER_TYPE_FRAME, frame, state, this._onPop_Handler ),
                onEnterFrame: this._prepareHandler( mediator, HANDLER_TYPE_DBG, frame, state, this._onEnterFrame_Handler )
            };
        },
        
        // onEnterFrame debugger handler.
        _onEnterFrame_Handler: function( mediator, frame, state, newFrame ) {
            
            // Notice that 'frame' points to the same frame for which '_stateHandlers' method was executed.
            if( env.isLoggerEnabled() ) {
                Utils.logLocation( newFrame, 'onEnterFrame' );
            }
            
            // Pause cleans current frame, so we have nothing to do here.
            try {
                mediator.pause( newFrame );
            } catch( ex ) {
                Utils.handleCallbackException( ex );
            }

        }
        
    });
    
    // **********************
    // State handler factory.
    // **********************
    
    function StateHandlerFactory() {
        this._stateHandlers = {
            "step": new StepStateHandler(),
            "next": new NextStateHandler()
        };
    }
    
    StateHandlerFactory.prototype = {
        create: function( state ) {
            return this._stateHandlers[ state ];
        }
    };
    
    // *****************
    // DbgCommandContext
    // *****************
    
    /**
     * Debugger mediator is low level debugger implemetation. This is 
     * the only class which is responsible for handling whole debugging 
     * logic using SpiderMonkey debugger API.
     */
    function DebuggerMediator( dbg )  {
        this._dbg = dbg;
        this._storage = {
            activeStateHandler: null,
            breakpoints: {},
            breakpointCounter: 0,
            older: null
        };
    }
    
    DebuggerMediator.prototype = {
    
        execute: function() {
        },
        
        /**
         * Initializes debugger mediator.
         */
        init: function() {
        
            /**
             * Handles: 'debugger' statement.
             */
            this._dbg.onDebuggerStatement = (function(frame) {
             
                /* onStep handler is already registered, so there is no 
                 * need to react on the debugger statement, because there is
                 * already something dedicated to handle it.  In other words
                 * we are inside STEP or NEXT state handler.
                 */
                if( frame.onStep ) {
                    return;
                }
                
                // Pause debuggee on the 'debugger' statement.
                try {
                    this.pause( frame );
                } catch( ex ) {
                    Utils.handleCallbackException( ex );
                }
                
            }).bind(this);
            
            /**
             * Currently only log the event, maybe we will find a good use for this
             * event in the future.
             */
            this._dbg.onNewScript = (function(script) {
                
                if( env.isLoggerEnabled() ) {
                    env.print( 'New script has been loaded: ' + script.url );
                }
                
                // Register pending breakpoints if there are any.
                dbg.registerPendingBreakpoints( script );
                
            }).bind(this);
            
            /**
             * Handles uncaught exceptions in the debugger code and broadcasts then to clients.
             */
            this._dbg.uncaughtExceptionHook = (function(exc) {
                
                var value = "Uncaught exception: " + exc.message ? exc.message : ( exc ? exc.toString() : 'No error message. Stack: ' + exc.stack  );
                
                env.log(value);
                
                // Broadcast this information to all clients.
                try {
                    env.sendCommand( BROADCAST, ProtocolStrategy.command_ERROR( value, null, ERROR_CODE_CANNOT_SET_BREAKPOINT ) );
                } catch( ex ) {
                    // Ignore this message. It has already been logged by the
                    // core engine and it shouldn't have any impact on the
                    // debugger itself.
                    Utils.logException( ex );
                }

            }).bind(this);
          
            // This is a one-time handler that is only responsible for
            // suspending the debuggee as soon as possible and then it is
            // removed immediately.
            if( env.options.suspended ) {
                this._dbg.onEnterFrame = (function( frame ) {
                    this._dbg.onEnterFrame = undefined;
                    // Pause debuggee on the 'debugger' statement.
                    try {
                        this.pause( frame, null, true );
                    } catch( ex ) {
                        Utils.handleCallbackException( ex );
                    }                    
                }).bind(this);
            } 
            
        },

        /**
         * Registers all pending breakpoints for given script. 
         */
        registerPendingBreakpoints: function( script ) {
            for( let bp in this._storage.breakpoints ) {
                let breakpoint = this._storage.breakpoints[bp];
                if( breakpoint.url === script.url ) {
                    try {
                        this._setBreakpointCore( script, breakpoint );
                        try {
                            env.sendCommand( BROADCAST, ProtocolStrategy.command_BREAKPOINT_SET( breakpoint ) );
                        } catch( exc ) {
                            // Async, error doesn't matter.
                            Utils.logException( exc );
                        }
                    } catch( exc ) {
                        try {
                            env.sendCommand( BROADCAST, ProtocolStrategy.command_ERROR( "Cannot install pending breakpoint: " +
                                breakpoint.id, null, ERROR_CODE_CANNOT_SET_BREAKPOINT, { bid: breakpoint.id } ) );
                        } catch( ex ) {
                            // Async, error doesn't matter.
                            Utils.logException( ex );
                        }
                    }
                }
            }
        },
        
        /**
         * Registers debuggee instance inside the debugger engine.
         * @param debuggee Debuggee instance.
         */
        addDebuggee: function( debuggee ) {
            this._dbg.addDebuggee( debuggee );
        },

        /**
         * Removes debuggee instance from the debugger engine.
         * @param debuggee Debuggee instance to be removed.
         */        
        removeDebuggee: function( debuggee ) {
            this._dbg.removeDebuggee( debuggee );
        },

        /**
         * Finds script by url.
         */
        findScripts: function( query ) {
            return query ? this._dbg.findScripts( query ) : this._dbg.findScripts();
        },
        
        /**
         * Looks for a breakpoint with given url and line.
         */
        findBreakpoint: function( url, line ) {
            var found = false;
            var breakpoint;
            for( let bp in this._storage.breakpoints ) {
                breakpoint = this._storage.breakpoints[bp];
                if( breakpoint.url === url && breakpoint.line === line ) {
                    found = true;
                    break;
                }
            }
            if( found ) {
                return breakpoint;
            }
            return null;
        },
        
        /**
         * Registers a new breakpoint.
         */
        setBreakpoint: function( url, line, pending ) {
            
            // Check if there is already break point for this url and line.
            // It doesn't matter if it's a pending breakpoint or not.
            var breakpoint = this.findBreakpoint( url, line );
            if( breakpoint ) {
                return breakpoint;
            }
            
            var scripts = this.findScripts( { 
                url: url,
                line: line,
                innermost: true
            } );
            
            breakpoint = {
                url: url,
                line: line,
                handler: { hit: this._breakpointHandler.bind( this ) },
                pending: false
            };
            
            if( scripts && scripts.length > 0 ) {
                this._setBreakpointCore( scripts[0], breakpoint );
            } else if( !pending ) {
                throw new MediatorException( "Script not found for given url." );
            } else {
                breakpoint.id = this._storage.breakpointCounter++;
                breakpoint.pending = true;
            }

            this._storage.breakpoints[breakpoint.id] = breakpoint;

            return breakpoint;
        },
        
        /**
         * Deletes breakpoint for with given ID.
         */
        deleteBreakpoint: function( ids ) {
            var deleted = [];
            if( !Array.isArray( ids ) ) {
                ids = [ids];
            }
            for( let index in ids ) {
                var id = ids[index];
                var breakpoint = this._storage.breakpoints[id];
                if( breakpoint ) {
                    if( !breakpoint.pending ) {
                        breakpoint.script.clearBreakpoint( breakpoint.handler );
                    }
                    delete this._storage.breakpoints[id];
                    deleted.push(id);
                }
            }
            return deleted;
        },
        
        /**
         * Gets all registered breakpoints.
         */
        getAllBreakpoints: function() {
            var breakpoints = [];
            for( let bp in this._storage.breakpoints ) {
                var breakpoint = this._storage.breakpoints[bp];
                breakpoints.push( {
                    bid: breakpoint.id,
                    url: breakpoint.url,
                    line: breakpoint.line,
                    pending: breakpoint.pending
                } );
            }
            return breakpoints;
        },
        
        /**
         * Deletes all registered breakpoints.
         */
        deleteAllBreakpoints: function() {
            this._dbg.clearAllBreakpoints();
            this._storage.breakpoints = {};
        },
        
        /**
         * Registers given state handler.
         */
        registerStateHandler: function( stateHandler ) {
        
            // If we are paused in a frame which has been already popped
            // out the older frame on the stack has higher precedence.
            var frame = this._storage.older;
        
            if( !frame ) {
                frame = this.getPC().getFrame();
            }
            
            var handlers = stateHandler.createStateHandlers( frame, this );
            
            // Store some information about current state handlers. It 
            // can be used to remove state handler being in use when
            // it is broken by 'debugger;' statement or breakpoint.
            this._storage.activeStateHandler = {
                handlers: handlers 
            };
            
            this.registerDebuggerHandlers( frame, handlers );
        },
        
        /**
         * Prepares information about stacktrace.
         */
        getStacktrace: function() {
            var stacktrace = [];
            var pc = this.getPC();
            var frame = pc.getFrame();
            let i = 0;
            do {
                stacktrace.push( this._getStackElement( i++, frame ) );
            } while( ( frame = frame.older ) !== null );
            return stacktrace;
        },
        
        /**
         * Gets basic information about stacktrace element.
         */
        _getStackElement: function( rDepth, frame ) {
            var script = frame.script;
            var url = null;
            var line = null;
            if( script ) {
                url = script.url;
                var offset = frame.offset;
                if( offset ) {
                    line = script.getOffsetLine( offset );
                }
            }
            var element = {
                url: url,
                line: line,
                depth: frame.depth,
                rDepth: rDepth
            };
            return element;
        },
    
        /**
         * Gets variables for stacktrace element.
         */    
        getVariables: function( depth, options ) {
            var variables = [];
            var pc = this.getPC();
            var frame = pc.getFrame();
            var i = 0;
            do {
                if( depth === null || depth === i ) {
                    var environment = {
                        stackElement: this._getStackElement( i, frame ),
                        variables: []
                    };
                    var env = frame.environment;
                    if( env ) {
                        var names = env.names();
                        for( let key in names ) {
                            var name = names[key];
                            var variable = env.getVariable( name );
                            environment.variables.push( {
                                name: name,
                                value: this.printVariable( variable, options )
                            } );
                        } 
                    }
                    variables.push(environment);
                }
                i++;
            } while( ( frame = frame.older ) !== null );
            return variables;
        },
        
        /**
         * Evaluate variable.
         */
        evaluateVariable: function( path, options ) {
            var value = null;
            var pc = this.getPC();
            var frame = pc.getFrame();
            var environment = frame.environment;
            if( environment ) {
                /*jshint -W061*/
                var lineNumber = pc.getLocation().getScriptLine();
                var result = frame.eval( path , { lineNumber: lineNumber } );
                if( env.isLoggerEnabled() ) {
                    env.print( 'Evaluation result: ' + result.return + ' type: ' + typeof( result.return ) );
                }
                if( result.return !== undefined ) {
                    let walker = new DebuggerObjectWalker( new DbgObjectTreeBuilder() );
                    value = walker.walkObj( result.return, options );
                    if( env.isLoggerEnabled() ) {
                       env.print( 'Converted evaluation result: ' + JSON.stringify( value ) );
                    }
                } else if( result.throw ) {
                    if( result.throw instanceof Debugger.Object ) {
                        throw new MediatorException( 'Evaluation exception (' + 
                            result.throw['class'] + '): ' + ( result.throw.message ? 
                            result.throw.message : 'No message.') );
                    }
                    throw new MediatorException( 'Evaluation failed due to an unknown error.' );
                }
            } else {
                throw new MediatorException( 'This stack frame doesn\'t allow evaluation.' );
            }
            return value;
        },
        
        /**
         * Prints given variable.
         */
        printVariable: function( value, options ) {
            let walker = new DebuggerObjectWalker( new DbgObjectTreeBuilder() );
            return walker.walkObj( value, options );
        },
        
        /**
         * True if debuggee is currently paused.
         */
        isPaused: function() {
            return this._storage.pause;
        },
        
        /**
         * Gets program counter.
         */
        getPC: function() {
            if( this._storage.pause ) {
                return this._storage.pc;
            }
            return null;
        },
        
        /**
         * Registers handlers inside frame and debugger.
         * Notice that state handlers are registered in the scope
         * of the debugger mediator instance.
         */
        registerDebuggerHandlers: function( frame, handlers ) {
            var state = handlers.state;
            state.cleaners = [];
            for( let handler in handlers ) {
                let handlerName = handler;
                if( handlerName !== 'state' ) {
                    var handlerDesc = handlers[handlerName];
                    switch( handlerDesc.type ) {
                    case HANDLER_TYPE_FRAME:
                        if( env.isLoggerEnabled() ) {
                            env.print( 'Registering ' + handlerName + ' state handler for frame.' );
                        }
                        frame[handlerName] = handlerDesc.handler.bind(this);
                        /*jshint -W083 */
                        state.cleaners.push( (function() {
                            if( env.isLoggerEnabled() ) {
                                env.print( 'Removing ' + handlerName + ' state handler from frame.' );
                            }
                            if( frame.live ) {
                                frame[handlerName] = undefined;
                            } else {
                                env.log( 'Cannot clean death frame. It\'s not an error - do not report it.' );
                            }
                        }).bind(this) );
                        break;
                    case HANDLER_TYPE_DBG:
                        if( env.isLoggerEnabled() ) {
                            env.print( 'Registering ' + handlerName + ' state handler for debugger.' );
                        }
                        this._dbg[handlerName] = handlerDesc.handler.bind(this);
                        /*jshint -W083 */
                        state.cleaners.push( (function() {
                            if( env.isLoggerEnabled() ) {
                                env.print( 'Removing ' + handlerName + ' state handler from debugger.' );
                            }
                            this._dbg[handlerName] = undefined;
                        }).bind(this) );
                        break;
                    }
                }
            }
        },
        
        /**
         * Cleans current state by calling all registered state cleaners.
         */
        _cleanCurrentState: function() {
            // Call all registered cleaners.
            var ash = this._storage.activeStateHandler;
            if( ash ) {
                let cleaners = ash.handlers.state.cleaners;
                if( cleaners ) {
                    for( let i in cleaners ) {
                        // Run cleaner.
                        try {
                            cleaners[i]();
                        } catch( exc ) {
                            Utils.logException( exc );
                        }
                    } 
                }
                this._storage.activeStateHandler = null;
            }
        },
        
        /**
         * Pauses the debuggee and waits for incoming commands.
         */
        pause: function(frame, older, suspended) {

            if( !suspended ) {
                suspended = false;
            }
            
            // Store older frame for future use if there is any.
            this._storage.older = older;
            
            try {
                
                this._cleanCurrentState();
            
                // There is no frame passed in the arguments, so get the active one.    
                if( !frame ) {
                    frame = this._dbg.getNewestFrame();
                }
                
                if( frame ) {
                
                    this._storage.pc = new ProgramCounter( frame );
                
                    try {
                        // Sends information to the clients that might be interested 
                        // about the fact that debugger has been paused.
                        env.sendCommand( BROADCAST, ProtocolStrategy.command_PAUSED( this._storage.pc ) );
                    } catch( exc ) {
                        // Cannot send the command. This is a broadcast, so this 
                        // error can be silently ignored anyway.
                        Utils.logException( exc );
                    }
                    
                    this._commandLoop( suspended );
                    
                } else {
                
                    // Broadcast this information to all clients.
                    try {
                        env.sendCommand( BROADCAST, ProtocolStrategy.command_ERROR( 'Cannot pause debuggee, no active frame found.', null, ERROR_CODE_NO_ACTIVE_FRAME ) );
                    } catch( ex ) {
                        Utils.logException( ex );
                    }
                    
                }
                
            } finally {
                this._storage.older = null;
            }
            
        },
        
        /**
         * Command execution loop. It waits for a command and executes it then.
         */
        _commandLoop: function( suspended ) {
            try {
                this._storage.pause = true;
                var result = env.waitForCommand( suspended );
                if( result === WFC_RES_INTERRUPTED ) {
                    // Debugger has been interrupted, so inform the command handler.
                    throw new DebuggerInterrupted();
                }
            } catch( ex ) {
                Utils.logException( ex );
                this._storage.pause = false;
                throw ex;
            }
            this._storage.pause = false;
        },
        
        /**
         * Handler for breakpoints.
         */
        _breakpointHandler: function( frame ) {
            // The same reason as in case of 'debugger;' statement handler above.
            if( frame.onStep ) {
                return;
            }
            try {
                this.pause( frame );
            } catch( ex ) {
                Utils.handleCallbackException( ex );
            }
        },
        
        /**
         * Sets native breakpoint for given script and breakpoint definition.
         */
        _setBreakpointCore: function( script, breakpoint ) {
        
            if( !script ) {
                throw new MediatorException( "JSScript not found." );
            }
        
            var line = breakpoint.line;
            
            var offsets = script.getLineOffsets( line );
            
            if( offsets && offsets.length > 0 ) {
            
                // Currently we are only interested in the first entry point's offset.
                if( breakpoint.id === undefined ) {
                    breakpoint.id = this._storage.breakpointCounter++;
                }
                
                breakpoint.offset = offsets[0];
                breakpoint.script = script;
                breakpoint.pending = false;
                
                script.setBreakpoint( breakpoint.offset, breakpoint.handler );
                
            } else {
                throw new MediatorException( "Cannot set breakpoint at given line." );
            }
    
        },
        
        /**
         * Cleans everything.
         */
        shutdown: function() {
            // Remove all breakpoints.
            this.deleteAllBreakpoints();
            // Remove active state handler if there is any.
            this._cleanCurrentState();
        }
       
    };
    
    // *****************
    // Commands factory.
    // ***************** 
    
    function ProtocolStrategy() {
    }
    
    /**
     * Prepares packet with source code.
     */
    ProtocolStrategy.command_SEND_SCRIPT = function( url, scriptLines, displacement ) {
        return {
            type: PKG_TYPE_INFO,
            subtype: "source_code",
            script: url,
            source: scriptLines,
            displacement: displacement
        };
    };
    
    /**
     * Prepares packed with information about the location
     * where debuggee has been paused and about the pausing itself.
     */
    ProtocolStrategy.command_PAUSED = function( pc ) {
        var location = pc.getLocation();
        return {
            type: PKG_TYPE_INFO,
            subtype: "paused",
            url: location.getURL(),
            line: location.getScriptLine(),
            source: Utils.getSourceLine( location )
        };
    };
    
    /**
     * Prepares packet with information about the location
     * where debuggee has been paused and about the pausing itself.
     */
    ProtocolStrategy.command_BREAKPOINT_SET = function( breakpoint ) {
        return {
            type: PKG_TYPE_INFO,
            subtype: "breakpoint_set",
            bid: breakpoint.id,
            url: breakpoint.url,
            line: breakpoint.line,
            pending: breakpoint.pending
        };
    };
    
    /**
     * Prepares packet with information that given breakpoint has been deleted.
     */
    ProtocolStrategy.command_BREAKPOINT_DELETED = function( ids ) {
        return {
            type: PKG_TYPE_INFO,
            subtype: "breakpoint_deleted",
            ids: ids
        };
    };
    
    /**
     * Prepares packet describing current program counter.
     */
    ProtocolStrategy.command_PC = function( pc, source ) {
        var location = pc.getLocation();
        return {
            type: PKG_TYPE_INFO,
            subtype: "pc",
            script: location.getURL(),
            line: location.getScriptLine(),
            source: source ? Utils.getSourceLine( location ) : null
        };
    };
       
    /**
     * Prepares packet describing current program counter.
     */
    ProtocolStrategy.command_BREAKPOINTS_LIST = function( breakpoints ) {
        return {
            type: PKG_TYPE_INFO,
            subtype: "breakpoints_list",
            breakpoints: breakpoints
        };
    };
    
    /**
     * Prepares packet describing current program counter.
     */
    ProtocolStrategy.command_ALL_BREAKPOINTS_DELETED = function() {
        return {
            type: PKG_TYPE_INFO,
            subtype: "all_breakpoints_deleted"
        };
    };
    
    /**
     * Prepares packet describing stacktrace.
     */
    ProtocolStrategy.command_STACKTRACE = function( stacktrace ) {
        return {
            type: PKG_TYPE_INFO,
            subtype: "stacktrace",
            stacktrace: stacktrace
        };
    };
    
    /**
     * Prepares packet variables.
     */
    ProtocolStrategy.command_VARIABLES = function( variables ) {
        return {
            type: PKG_TYPE_INFO,
            subtype: "variables",
            variables: variables
        };
    };

    /**
     * Prepares error package.
     */    
    ProtocolStrategy.command_ERROR = function( msg, id, code, ext ) {
        var error = {
            type: PKG_TYPE_ERROR,
            message: msg,
            code: code,
            id: id
        };
        if( ext ) {
            for( let prop in ext ) {
                error[prop] = ext[prop];
            } 
        }
        return error;
    };
    
    /**
     * Evaluates variable value.
     */    
    ProtocolStrategy.command_EVALUATE = function( value ) {
        return {
            type: PKG_TYPE_INFO,
            subtype: "evaluated",
            result: value
        };
    };
    
    /**
     * Evaluates variable value.
     */    
    ProtocolStrategy.command_SEND_ALL_SOURCE_URLS = function( urls ) {
        return {
            type: PKG_TYPE_INFO,
            subtype: "all_source_urls",
            urls: urls
        };
    };
    
    // *****************
    // DbgCommandContext
    // *****************
    
    function DbgCommandContext() {
    }
    
    DbgCommandContext.prototype = {
    };

    // *****************
    // DbgCommandFactory
    // *****************
    
    function DbgCommandFactory() {
    }
    
    DbgCommandFactory.prototype = {
        
        /**
         * Creates command for given command name. 
         */
        createCommand: function( command ) {
            var def = this._commands[ command ];
            if( def ) {
                if( def.needPause ) {
                    return (function( ctx ) {
                        if( !ctx.debuggerMediator.isPaused() ) {
                            throw new DbgException( "Debuggee has to be paused.", ERROR_CODE_NOT_PAUSED );
                        }
                        return def.fn.call(this, ctx);
                    }).bind( this ); 
                } else {
                    return def.fn.bind( this );
                }
            }
            return null;
        },
        
        /**
         * Creates state handler and executes it in the context of debugger mediator.
         */
        _stateHandlerCommand: function( state, ctx ) {
            var stateHandler = ctx.stateHandlerFactory.create( state );
            if( stateHandler ) {
                stateHandler.register( ctx.debuggerMediator );
            } else {
                throw new DbgException( 'Unsupported state handler: ' + state, ERROR_CODE_UNKNOWN_COMMAND );
            }
            // No matter which state handler has been chosen
            // they are designed to operate on frame and debugger
            // events, so we have to awake debugger.
            return HC_RES_CONTINUE;
        },
        
        /**
         * Commands definitions.
         */
        _commands: {

            /**
             * Steps to the next line.
             */
            'step': {
                needPause: true,
                fn: function( ctx ) {
                    return this._stateHandlerCommand( 'step', ctx );
                }
            },

            /**
             * finishes the continuation of the current function body
             */
            'step_out': {
                needPause: true,
                fn: function(ctx) {
                    var frame  = ctx.debuggerMediator.
                                        getPC().getFrame();
                    var stopFunction = function() {
                        ctx.debuggerMediator.pause();
                    };
                    var listener = frame.older ? frame.older.onStep : frame.onPop ;
                    if(listener){
                        listener = stopFunction;
                    }
                    return HC_RES_CONTINUE;
                 }
            },

            /**
             * Steps to the next line proceeding through subroutines.
             */
            'next': {
                needPause: true,
                fn: function( ctx ) {
                    return this._stateHandlerCommand( 'next', ctx );
                }
            },

            /**
             * Breaks the pause and makes the debuggee to continue its job.
             */
            'continue': {
                needPause: true,
                fn: function( ctx ) {
                    return HC_RES_CONTINUE;
                }
            },

            /**
             * Terminates the debuggee.
             */
            'stop': {
                needPause: true,
                fn: function( ctx ) {
                    var pc = ctx.debuggerMediator.getPC();
                    var frame = pc.getFrame();
                    frame.onStep = function () {
                        // Returning null from this handler will explicitly
                        // terminate debuggee execution.
                        return null;
                    };
                    return HC_RES_CONTINUE;
                }
            },

            /**
             * Sets a new breakpoint.
             */
            'set_breakpoint': {
                needPause: false,
                fn: function( ctx ) {
                    var command = ctx.command.breakpoint;
                    if( !command || !command.url || typeof(command.line) !== 'number' ) {
                        throw new DbgException( "Script or line not available.", ERROR_CODE_BAD_ARGS );
                    }
                    try {
                        var breakpoint = ctx.debuggerMediator.setBreakpoint( command.url, command.line, !!command.pending );
                        ctx.sendCommand( ProtocolStrategy.command_BREAKPOINT_SET( breakpoint ) );
                    } catch( ex ) {
                        if( ex instanceof MediatorException ) {
                            throw new DbgException( ex.msg, ERROR_CODE_CANNOT_SET_BREAKPOINT );
                        }
                        throw ex;
                    }
                    return HC_RES_IGNORE;
                }
            },

            /**
             * Deletes given breakpoint.
             */
            'delete_breakpoint': {
                needPause: false,
                fn: function( ctx ) {
                    var ids = ctx.command.ids;
                    if( typeof(ids) === 'undefined' ) {
                        throw new DbgException( "Breakpoints identificators not set.", ERROR_CODE_BAD_ARGS );
                    }
                    ctx.sendCommand( ProtocolStrategy.command_BREAKPOINT_DELETED( ctx.debuggerMediator.deleteBreakpoint( ids ) ) );
                    return HC_RES_IGNORE;
                }
            },

            /**
             * Deletes given breakpoint.
             */
            'get_breakpoints': {
                needPause: false,
                fn: function( ctx ) {
                    ctx.sendCommand( ProtocolStrategy.command_BREAKPOINTS_LIST( ctx.debuggerMediator.getAllBreakpoints() ) );
                    return HC_RES_IGNORE;
                }
            },

            /**
             * Deletes given breakpoint.
             */
            'delete_all_breakpoints': {
                needPause: false,
                fn: function( ctx ) {
                    ctx.debuggerMediator.deleteAllBreakpoints();
                    ctx.sendCommand( ProtocolStrategy.command_ALL_BREAKPOINTS_DELETED() );
                    return HC_RES_IGNORE;
                }
            },

            /**
             * Sends current program counter to the client.
             */
            'pc': {
                needPause: true,
                fn: function( ctx ) {
                    var pc = ctx.debuggerMediator.getPC();
                    if( pc !== null ) {
                         ctx.sendCommand( ProtocolStrategy.command_PC( pc, ctx.command.source ) );
                    } else {
                         throw new DbgException( "Program counter is not available.", ERROR_CODE_PC_NOT_AVAILABLE );
                    }
                    return HC_RES_IGNORE;
                }
            },

            /**
             * Pauses virtual machine.
             */
            'pause': {
                needPause: false,
                fn: function( ctx ) {
                    env.log( 'Debugger paused.' );
                    if( ctx.debuggerMediator.isPaused() ) {
                        throw new DbgException( "Debuggee is already paused.", ERROR_CODE_IS_PAUSED );
                    }
                    ctx.debuggerMediator.pause();
                    return HC_RES_CONTINUE;
                }
            },

            /**
             * Gets stacktrace for current program pointer.
             */
            'get_stacktrace': {
                needPause: true,
                fn: function( ctx ) {
                    ctx.sendCommand( ProtocolStrategy.command_STACKTRACE( ctx.debuggerMediator.getStacktrace() ) );
                    return HC_RES_IGNORE;
                }
            },

            /**
             * Gets variables for set of environments.
             */
            'get_variables': {
                needPause: true,
                fn: function( ctx ) {
                    var depth = null;
                    var options = {};
                    if( typeof( ctx.command.query ) !== 'undefined' ) {
                        if( typeof(ctx.command.query.depth) !== 'undefined' ) {
                            depth = ctx.command.query.depth;
                        }
                        if( ctx.command.query.options ) {
                            options = ctx.command.query.options;
                        }
                    }
                    ctx.sendCommand( ProtocolStrategy.command_VARIABLES( ctx.debuggerMediator.getVariables( depth, options ) ) );
                    return HC_RES_IGNORE;
                }
            },

            /**
             * Evaluates given variable.
             */            
            'evaluate': {
                needPause: true,
                fn: function( ctx ) {
                    if( !ctx.command.path ) {
                        throw new DbgException( "Variable path not found.", ERROR_CODE_BAD_ARGS );
                    }
                    try {
                        var evalResult = ctx.debuggerMediator.evaluateVariable( ctx.command.path, ctx.command.options );
                        ctx.sendCommand( ProtocolStrategy.command_EVALUATE ( evalResult ) );
                    } catch( ex ) {
                        if( ex instanceof MediatorException ) {
                            throw new DbgException( ex.msg, ERROR_CODE_EVALUATION_FAILED );
                        }
                        throw ex;
                    }
                    return HC_RES_IGNORE;
                }
            },
            
            /**
             * Loads source file.
             */
            'get_source': {
                needPause: false,
                fn: function( ctx ) {
                    if( !ctx.command.url ) {
                        throw new DbgException( "Source URL not found.", ERROR_CODE_BAD_ARGS );
                    }
                    let script = scriptsRepository.getScriptSourceCode( ctx.command.url, -1, null );
                    if( script ) {
                        let sourceCode = script.getAllSourceLines();
                        ctx.sendCommand( ProtocolStrategy.command_SEND_SCRIPT( ctx.command.url, sourceCode, env.options.sourceDisplacement ) );
                    } else {
                        throw new DbgException( "Script not found: " + ctx.command.url, ERROR_CODE_SCRIPT_NOT_FOUND );
                    }
                    return HC_RES_IGNORE;
                }
            },
            
            /**
             * Loads all source URLs.
             */
            'get_all_source_urls': {
                needPause: false,
                fn: function( ctx ) {
                    // Notice that this operation doesn't use internal
                    // source code cache but engine directly.
                    let sources = scriptsRepository.getAllSourceCodes();
                    if( sources ) {
                        var urls = [];
                        sources.forEach( function( source ) {
                            urls.push(source.url);
                        });
                        ctx.sendCommand( ProtocolStrategy.command_SEND_ALL_SOURCE_URLS( urls ) );
                    } else {
                        throw new DbgException( 'There are no script files loaded.', ERROR_CODE_SCRIPT_NOT_FOUND );
                    }
                    return HC_RES_IGNORE;
                }
            }
            
        }
        
    };
    
    // **********
    // JSDebugger
    // **********

    function JSDebugger( commandFactory, stateHandlerFactory ) {
        this._dbg = new Debugger();
        this._commandFactory = commandFactory;
        this._stateHandlerFactory = stateHandlerFactory;
        this._debuggerMediator = new DebuggerMediator( this._dbg );
    }
    
    JSDebugger.prototype = {
    
        init: function() {
            this._debuggerMediator.init();
        },
        
        /**
         * Finds script source for given query.
         */
        findScripts: function( query ) {
            return this._debuggerMediator.findScripts( query );
        },
        
        /**
         * Registers pending breakpoints for given script.
         */
        registerPendingBreakpoints: function( script ) {
            this._debuggerMediator.registerPendingBreakpoints( script );
        },
        
        /**
         * Registers debuggee instance inside the debugger engine.
         * @param debuggee Debuggee instance.
         */
        addDebuggee: function( debuggee ) {
            this._debuggerMediator.addDebuggee( debuggee );
        },

        /**
         * Removes debuggee instance from the debugger engine.
         * @param debuggee Debuggee instance to be removed.
         */        
        removeDebuggee: function( debuggee ) {
            this._debuggerMediator.removeDebuggee( debuggee );
        },
        
        /**
         * Handles incoming command.
         */
        handleCommand: function( clientId, command ) {
        
            var id = (command.id) ? command.id : null;
            
            if( (!command.type) || (command.type !== "command") ) {
                throw new DbgException( 'Not a command packet.', ERROR_CODE_NOT_A_COMMAND_PACKAGE );
            }
            
            if( !command.name ) {
                throw new DbgException( 'Command name not found.', ERROR_CODE_NO_COMMAND_NAME );
            }
            
            var commandFunction = this._commandFactory.createCommand( command.name );
            if( !commandFunction ) {
                throw new DbgException( 'Unknown command.', ERROR_CODE_UNKNOWN_COMMAND );
            }
            
            var ctx = new DbgCommandContext();
            
            ctx.command = command;
            ctx.clientId = clientId;
            ctx.debuggerMediator = this._debuggerMediator;
            ctx.stateHandlerFactory = this._stateHandlerFactory;
            
            // Sends a generic command to the client.
            ctx.sendCommand = function( cmd ) {
                // Send id back if there is any.
                if( id ) {
                    cmd.id = id;
                }
                try {
                    env.sendCommand( clientId, cmd );
                } catch( exc ) {
                    // Throwing exception has no sense in this case, because
                    // it won't be sent to the client anyway. In addition remember
                    // that this operation is fully asynchronous and it doesn't inform
                    // us about any errors that might occur in the future, so it's
                    // just impossible to handle every error here. Potential errors
                    // are logged by the core engine (native code).
                    Utils.logException( exc );
                }
            };
            
            return commandFunction( ctx );
        },
        
        /**
         * Closes the debugger.
         */
        shutdown: function() {
            this._debuggerMediator.shutdown();
        },
        
    };

    /*
     * Tracks all scripts registered for all debuggees.
     */

    function SourceCode( url, sourceCode, source ) {
        this._url = url;
        if( !sourceCode ) {
            sourceCode = 'No source code.';
        }
        this._sourceCode = sourceCode;
        this._sourceCodeLines = this._parseSourceCode( sourceCode );
        this._source = source;
    }
    
    SourceCode.prototype = {
    
        /**
         * Gets URL object.
         */
        getURL: function() {
            return this._url;
        },
    
        /**
         * Gets line from the managed source code.
         * @param lineNumber The line number.
         * @return Line of the text from the source code or undefined if there is no 
         *         such line (When index is out of bound for example).
         */
        getSourceLine: function ( lineNumber ) {
            if( ( lineNumber < 0 ) || ( lineNumber >= this._sourceCodeLines.length ) ) {
                return null;
            }
            return this._sourceCodeLines[lineNumber + env.options.sourceDisplacement];
        },
        
        /**
         * Returns all source lines as an array.
         */
        getAllSourceLines: function() {
            return this._sourceCodeLines;
        },
        
        /**
         * Gets script associated with the source code.
         */
        getSource: function() {
            return this._source;
        },
        
        /**
         * Splits source code into lines.
         * @param sourceCode Source code.
         * @return Source code as the array of strings.
         */
        _parseSourceCode: function( sourceCode ) {
            var regExp = new RegExp('(\\r\\n)|(\\n\\r)|(\\r)|(\\n)','gm');
            var lastIndex = 0;
            var matches;
            var lines = [];
            while( ( matches = regExp.exec( sourceCode ) ) !== null ) {
                lines.push( matches.input.substring( lastIndex, matches.index ) );
                lastIndex = regExp.lastIndex;
            }
            if( lastIndex < sourceCode.length ) {
                lines.push( sourceCode.substring( lastIndex, sourceCode.length ) );
            }
            return lines;
        }
        
    };

    function ScriptRepository() {
        (function(dest) {
            var scripts = {};
            dest.getScripts = function() {
                return scripts;
            };
        })(this);
    }

    ScriptRepository.prototype = {

        getScriptSourceCode: function( url, line, script ) {

            var source = null;

            // Find source object associated with given URL.
            if( !script || script.url !== url ) {
            
                // This script cannot be used, so forget about it.
                script = null;
                
                let query = {
                    url: url
                };
                
                if( line && line !== -1 ) {
                    query.line = line;
                }
                
                let dbgScripts = dbg.findScripts(query);
                
                if( dbgScripts && dbgScripts.length > 0 ) {
                    script = dbgScripts[0];
                }
                
                if( script && script.source ) {
                    source = script.source;
                }
                
            } else {
                source = script.source;
            }

            // Check if source code is already cached.
            var scripts = this.getScripts();
            if( scripts[url] ) {
                var sourceDef = scripts[url];
                if( sourceDef && sourceDef.getSource() === source ) {
                    return sourceDef;
                }
            }
            
            if( source && env.isLoggerEnabled() ) {
                env.log( "Source code returned by the engine:\n---\n" + env.getSourceSafe( source ) + "\n---\n" );
                if( script ) {
                    env.log( "Start line: " + script.startLine );
                    env.log( "Line count: " + script.lineCount );
                    env.log( "Source start: " + script.sourceStart );
                }
            }

            // Cache has to be reloaded.
            let sourceCode;
            if( source ) {
                sourceCode = env.getSourceSafe( source );
            } 

            if( !sourceCode ) {
                // There is no source associated with this URL, so check if this is an
                // external source that can be loaded by provided source loader.
                sourceCode = env.loadScriptSource( url );
            }

            if( sourceCode ) {
                // Put source code into a cache, but only and only if there is source code available.
                let sc = new SourceCode( url, sourceCode, source );
                scripts[url]  = sc;
                return sc;
            } else {
                return null;
            }
        },
        
        /**
         * Returns all source objects without duplicates.
         */
        getAllSourceCodes: function() {
            var scripts = dbg.findScripts();
            var sources = {};
            if( scripts ) {
                scripts.forEach( function( script ) {
                    if( script.url && script.url !== 'debugger eval code' && script.source ) {
                        sources[script.url] = script.source;
                    }
                });
            }
            var result = [];
            for( let url in sources ) {
                result.push( {
                    url:url,
                    source: sources[url]
                } );
            }
            return result;
        }

    };

    var scriptsRepository = new ScriptRepository();

    var dbg = new JSDebugger( new DbgCommandFactory(), new StateHandlerFactory() );

    dbg.init();

    return {
    
        /**
         * Registers debuggee instance inside the debugger engine.
         * @param debuggee Debuggee instance.
         */
        addDebuggee: function( debuggee ) {
            dbg.addDebuggee( debuggee );
        },

        /**
         * Removes debuggee instance from the debugger engine.
         * @param debuggee Debuggee instance to be removed.
         */        
        removeDebuggee: function( debuggee ) {
            dbg.removeDebuggee( debuggee );
        },
        
        /**
         * Use it to connect new client as a unit which is able to control and 
         * monitor debugger state. The connection object is the only way hosting
         * code can get into interaction with debugger.
         *
         * @param conn Remote connection to the debugger.
         */
        handleCommand: function( clientId, command ) {
            
            if( env.isLoggerEnabled() ) {
                env.print( 'Command: ' + JSON.stringify( command ) + ' from client: ' + clientId );
            }
            
            var result;
            
            try {
            
                result = dbg.handleCommand( clientId, command );
                if( env.isLoggerEnabled() ) {
                    env.print('Command result (' +  clientId + '/' + command.name + '): ' + result);
                }
                
            } catch( e ) {
            
                Utils.logException( e );
            
                // Debugger has been interrupted, so we have to continue the debuggee application and shutdown the debugger.
                if( e instanceof DebuggerInterrupted ) {
                    env.log('Debugger has been interrupted.');
                    return HC_RES_INTERRUPTED;
                }
    
                let msg;
                let code;
                
                if( e instanceof DbgException ) {
                    msg = e.msg;
                    code = e.code;
                } else {
                    msg = e.message ? e.message : e.toString();
                    code = ERROR_CODE_UNEXPECTED_EXC;
                }
            
                try {
                    env.sendCommand( clientId, ProtocolStrategy.command_ERROR( msg, command.id ? command.id : null, code ) );
                } catch( exc ) {
                    Utils.logException( exc );
                }
                
                // We cannot predict how the unexpected exceptions should
                // be handled, so it's the best to just leave everything as it is.
                result = HC_RES_IGNORE;
            }
            return result;
        },
        
        /**
         * Shutdowns the debugger.
         */
        shutdown: function() {
            dbg.shutdown();
        }
        
    };
    
})();

